 # Step 1: Design State Management
- Follow the instructions in `@ai-state-design` to define the applicationâ€™s state requirements.
- Create a spec in `state.md` listing state variables, their scope (e.g., global, local), and transitions.
- Use Cursor AI to validate the design and optimize for performance or simplicity.

# Step 2: Implement State Management
- Use Cursor AI to generate state management code.
  - For Go, use structs and mutexes for thread-safe state.
  - For JavaScript/TypeScript, use Redux, Context API, or a custom solution.
- Ensure state updates are predictable and side-effect-free.

# Step 3: Integrate State into Application
- Connect state to components, services, or APIs that rely on it.
- Use Cursor AI to check for race conditions or stale state issues.
- Add logging or debugging tools to monitor state changes.

# Step 4: Test State Management
- Follow the instructions in `@ai-tests` to write tests for state behavior.
- Generate tests with Cursor AI for:
  - State initialization and updates.
  - Concurrent access (if applicable).
  - Recovery from invalid state.
- Run tests and iterate until state handling is reliable.

# Step 5: Optimize and Scale
- Use Cursor AI to analyze state performance under load and suggest optimizations (e.g., memoization).
- Document the final state design in `state.md` for future reference.