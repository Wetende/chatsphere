# Step 1
Follow the instructions in `@ai-performance` to analyze the codebase and identify performance hotspots.
- Use Cursor AI to pinpoint slow functions or database queries that would benefit from caching.
- Determine which data is frequently accessed and suitable for caching.

# Step 2
Based on the analysis, decide on a caching strategy.
- For in-memory caching, use Go's `sync.Map` or a similar structure.
- For distributed systems, consider Redis or another external cache.
- Use Cursor AI to generate the initial caching logic.

# Step 3
Integrate the caching logic into the existing codebase.
- Ensure cache keys are unique and consistent across the project.
- Add cache invalidation logic to handle data updates.

# Step 4
Follow the instructions in `@ai-tests` to write tests for the caching layer.
- Generate tests with Cursor AI to validate cache hits, misses, and eviction behavior.
- Run the tests and iterate until the caching layer works reliably. 